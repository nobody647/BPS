#include <stdint.h>
#include <algorithm>
#include "can_messages.h"
#include "functions.hpp"
#include "pin_defs.h"

#include <vector> // not using vectors, just std::begin();
using std::begin; using std::end;

////////////////////////////////////////////////////////////////

/*
 *  Function that will isolate the pack from the rest of the car
 *  Should this also send a message about the fact that it did it???????
 *    Yes
 *  Should stop functioning after this function is called.
 */
void isolate_pack() {
    // Then open all of the main control relays
    // Open the negative relay
    digitalWrite(RELAY1_LOW_SIDE, LOW);
    // Open the precharge relay
    digitalWrite(RELAY2_HIGH_SIDE, LOW);
    // Open the positive relay
    digitalWrite(RELAY3_PRECHARGE, LOW);
    // Open the array relay
    digitalWrite(RELAY4_MPPT, LOW);

    // Set the state flag
    precharge_state = off;

    Serial.println("PACK ISOLATED!!!!!!!!!!!!!!!");
    Serial.println("///////////////////////////////////////////////////////////");

    // TODO: Send a CAN message. Don't worry about this for now

    // delay(10000);
}

void check_voltage() {
    // check for above max voltage
    uint8_t high_voltage_count =
        std::count_if(begin(high_voltage_array), end(high_voltage_array),
                      [](const measurement_40_t &m) { return m.data > HIGH_VOLTAGE_LIMIT; });

    if (high_voltage_count >
        (DATA_POINTS_TO_STORE / 2)) {  // if more than half of the voltage measurements are too high
        isolate_pack();
    }

    // check for below min voltage
    uint8_t low_voltage_count =
        std::count_if(begin(low_voltage_array), end(low_voltage_array),
                      [](const measurement_40_t &m) { return m.data < LOW_VOLTAGE_LIMIT; });

    if (low_voltage_count >
        (DATA_POINTS_TO_STORE / 2)) {  // if more than half of the voltage measurements are too high
        isolate_pack();
    }

    // check for old data
    uint8_t old_data_count = std::count_if(
        begin(high_voltage_array), end(high_voltage_array),
        [](const measurement_40_t &m) { return ((uint16_t)millis() - m.timestamp) > AGE_LIMIT; });
    if (old_data_count >
        (DATA_POINTS_TO_STORE / 2)) {  // if more than half of the timestamps are too old
        isolate_pack();
        return;
    }

    old_data_count = std::count_if(
        begin(low_voltage_array), end(low_voltage_array),
        [](const measurement_40_t &m) { return ((uint16_t)millis() - m.timestamp) > AGE_LIMIT; });
    if (old_data_count >
        (DATA_POINTS_TO_STORE / 2)) {  // if more than half of the timestamps are too old
        isolate_pack();
        return;
    }
}

void check_temp() {
    // check for above max temp
    uint8_t high_temp_count =
        std::count_if(begin(temp_array), end(temp_array),
                      [](const measurement_48_t &m) { return m.data > TEMP_LIMIT; });

    if (high_temp_count >
        (DATA_POINTS_TO_STORE / 2)) {  // if more than half of the temp measurements are too high
        isolate_pack();
    }

    // check for old data
    uint8_t old_data_count = std::count_if(
        begin(temp_array), end(temp_array),
        [](const measurement_48_t &m) { return ((uint16_t)millis() - m.timestamp) > AGE_LIMIT; });
    if (old_data_count >
        (DATA_POINTS_TO_STORE / 2)) {  // if more than half of the timestamps are too old
        isolate_pack();
    }
}

void check_current() {
    // check for above max current
    uint8_t high_current_count =
        std::count_if(begin(current_array), end(current_array),
                      [](const measurement_32_t &m) { return m.data > CURRENT_LIMIT; });

    if (high_current_count >
        (DATA_POINTS_TO_STORE / 2)) {  // if more than half of the current measurements are too high
        isolate_pack();
    }

    // check for old data
    uint8_t old_data_count = std::count_if(
        begin(current_array), end(current_array),
        [](const measurement_32_t &m) { return ((uint16_t)millis() - m.timestamp) > AGE_LIMIT; });
    if (old_data_count >
        (DATA_POINTS_TO_STORE / 2)) {  // if more than half of the current measurements are too high
        isolate_pack();
    }
}


//ross's code, TODO: make it work
void check_precharge_switch()  // this is what the current precharge cycle function is.  no e-stop
                               // sense yet
{
    if (precharge_state == off && digitalRead(PRECHARGE_SWITCH) == LOW && precharge_switch_reset) {
        delay(100);
        digitalWrite(RELAY1_LOW_SIDE, HIGH);
        delay(100);
        digitalWrite(RELAY2_HIGH_SIDE, HIGH);
        delay(10000);  // 10 seconds to charge. TODO: Eventually integrate current sensing instead
                       // of just waiting
        digitalWrite(RELAY3_PRECHARGE, HIGH);
        precharge_state = running;
        precharge_switch_reset = false;
    } else if (precharge_state == 1 && digitalRead(PRECHARGE_SWITCH) == LOW &&
               precharge_switch_reset) {
        // isolate_pack();
        precharge_state = off;
        precharge_switch_reset = false;
        delay(300);
    } else if (digitalRead(PRECHARGE_SWITCH) == HIGH) {
        precharge_switch_reset = true;
        delay(10);
    }
}

////////////////////////////////////////////////////////////////////////

void frame0_handler(CAN_FRAME *frame) {
    measurement_32_t current;
    current.data = frame->data.s0;
    current.timestamp = millis();

    current_array[current_index] = current;
    current_index++;
    current_index %= DATA_POINTS_TO_STORE;
}

void frame1_handler(CAN_FRAME *frame) {
    measurement_40_t high_voltage;
    high_voltage.cell_id = frame->data.bytes[0];  // first byte from can frame is high voltage cell ID
    high_voltage.data = frame->data.s1;     // bytes 2-3 contain the voltage of the high cell
    high_voltage.timestamp = millis();

    measurement_40_t low_voltage;
    low_voltage.cell_id = frame->data.bytes[1];  // first byte from can frame is high voltage cell ID
    low_voltage.data = frame->data.s2;     // bytes 2-3 contain the voltage of the high cell
    low_voltage.timestamp = millis();

    high_voltage_array[high_voltage_index] = high_voltage;
    high_voltage_index++;
    high_voltage_index %= DATA_POINTS_TO_STORE;

    low_voltage_array[low_voltage_index] = low_voltage;
    low_voltage_index++;
    low_voltage_index %= DATA_POINTS_TO_STORE;
}

void frame2_handler(CAN_FRAME *frame) {
    measurement_48_t high_temp;
    high_temp.therm_id = frame->data.s0;
    high_temp.data = frame->data.s2;
    high_temp.timestamp = millis();

//    measurement_48_t low_temp;
//    low_temp.therm_id = frame->data.s1;
//    low_temp.data = frame->data.s3;
//    high_temp.timestamp = millis();

    temp_array[temp_index] = high_temp;
    temp_index++;
    temp_index %= DATA_POINTS_TO_STORE;

//    low_tempa_array[low_temp_index] = low_temp;
//    low_temp_index++;
//    low_temp_index %= DATA_POINTS_TO_STORE;
}

////////////////////////////////////////////////////////

void print_frame(CAN_FRAME *frame) {  // this is good for testing to see if you are getting the
                                      // right values before conversion
    Serial.print("ID: 0x");
    Serial.print(frame->id, HEX);
    Serial.print(" Len: ");
    Serial.print(frame->length);
    Serial.print(" Data: 0x");
    for (int count = 0; count < frame->length; count++) {
        Serial.print(frame->data.bytes[count], HEX);
        Serial.print(" ");
    }
    Serial.print("\r\n");
}

////////////////////////////////////////////////////

// void print_vals() {
//     Serial.print("\n\npack_current : ");
//     Serial.print(pack_current);
//     Serial.print("    ");
//     Serial.println(pack_current_d);
//     Serial.print("absolute max pack current : ");
//     Serial.println(max_pack_current_d);

//     Serial.print("pack_inst_voltage : ");
//     Serial.println(pack_inst_voltage_d);
//     Serial.print("pack_soc : ");
//     Serial.println(pack_soc_d, 1);
//     Serial.print("pack_health : ");
//     Serial.println(pack_health);
//     Serial.print("high_cell_voltage_id : ");
//     Serial.println(high_cell_voltage_id);
//     Serial.print("low_cell_voltage_id : ");
//     Serial.println(low_cell_voltage_id);
//     Serial.print("high_cell_voltage = : ");
//     Serial.println(high_cell_voltage_d, 4);

//     Serial.print("low_cell_voltage : ");
//     Serial.println(low_cell_voltage_d, 4);
//     Serial.print("absolute lowest cell voltage : ");
//     Serial.println(abs_low_voltage, 4);

//     Serial.print("high_thermistor_id : ");
//     Serial.println(high_thermistor_id);
//     Serial.print("low_thermistor_id : ");
//     Serial.println(low_thermistor_id);
//     Serial.print("high_temperature : ");
//     Serial.println(high_temperature_d);
//     Serial.print("low_temperature : ");
//     Serial.println(low_temperature_d);
// }

// right now its set up to print the voltage values to the output, but should
// return the voltage value to complete its sole functions as a helper class (get the voltage)

///////////////////////////////////////////////////////////////////

/*
 *  Function to handle the hitting of the estop
 *  Basically just turns on a mosfet to create a temporary connection
 *    while the mechanical relay is closing
 *
  CAN_FRAME outgoing;
  outgoing.id = BMS_CAN_BASE + SHITS_FUCKED;
  outgoing.extended = true;
  outgoing.data.high = 0x55AAEE22;
  outgoing.data.low = 0x55AAEE22;
  outgoing.length = 8;
  Can0.sendFrame(outgoing);

 */
